---
title: Never
author: Mattt
category: Swift
excerpt: >
  Affirmer que quelque chose n'aura jamais lieu peut ressembler
  √† inviter l'univers √† prouver le contraire.
  Heureusement pour nous, 
  Swift sait se pr√©munir contre cette √©ventualit√© gr√¢ce √† un type des
  plus improbables : `Never`.
status:
  swift: 4.2
---

"Jamais" est une indication qu'un √©v√®nement n'a pas lieu,
√† aucun moment du pass√© ou du futur.
C'est une impossibilit√© logique sur la fl√®che du temps ;
un vide qui s'√©tire dans toutes les directions, pour toujours.

...c'est pourquoi il est particuli√®rement pr√©occupant de rencontrer
[ce commentaire](https://github.com/search?q=%22this+will+never+happen%22&type=Code)
dans un code :

```swift
// ceci n'aura jamais lieu
```

Tous les manuels de compilateurs vous expliquerons qu'un tel commentaire
ne peut et ne va pas affecter le comportement d'un code compil√©.
La [Loi de Murphy](https://fr.wikipedia.org/wiki/Loi_de_Murphy) n'est pas
du m√™me avis.

Comment Swift parvient-il √† √™tre s√ªr dans l'impr√©dictible chaos qu'est
la programmation ?
La r√©ponse va vous surprendre : en ne **faisant rien** et en **provoquant
des crashs**.

---

`Never` f√ªt propos√© comme remplacement pour l'attribut `@noreturn` dans
la proposition d'√©volution [SE-0102: "Remove @noreturn attribute and introduce an empty Never type"](https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md) de [Joe Groff](https://github.com/jckarter).

Ant√©rieurement √† Swift 3,
les fonctions qui mettent fin √† l'ex√©cution, comme
`fatalError(_:file:line:)`,
`abort()`, et
`exit(_:)`, √©taient annot√©es avec l'attribut `@noreturn`,
qui indiquait au compilateur qu'il n'y aurait pas de retour
√† l'appelant.

```swift
// Swift < 3.0
@noreturn func fatalError(_ message: () -> String = String(),
                               file: StaticString = #file,
                               line: UInt = #line)
```

Apr√®s la modification,
`fatalError` et consorts d√©clarent retourner le type `Never` :

```swift
// Swift >= 3.0
func fatalError(_ message: @autoclosure () -> String = String(),
                     file: StaticString = #file,
                     line: UInt = #line) -> Never
```

Pour qu'un type soit capable de remplacer une annotation,
il doit se r√©v√©ler plut√¥t complexe ?
Non ! C'est en fait l'oppos√© --- `Never` est peut √™tre le type
le plus simple de toute la librairie standard Swift :

```swift
enum Never {}
```

## Types Inhabit√©s

`Never` est un type <dfn>inhabit√©</dfn>,
c'est √† dire qu'il ne poss√®de pas de valeurs.
Ou bien, pour le dire autrement, un type inhabit√© ne peut pas
√™tre construit.

Des √©num√©rations qui ne poss√®dent aucun cas sont l'exemple
le plus courant de types inhabit√©s en Swift.
√Ä la diff√©rence des structures et des classes,
les √©num√©rations ne re√ßoivent pas de constructeurs.
Et contrairement aux protocoles,
les √©num√©rations sont des types concrets,
qui peuvent poss√©der des propri√©t√©s, m√©thodes, contraintes g√©n√©riques,
et types imbriqu√©s.
√Ä cause de cela,
les √©num√©rations vides sont utilis√©es √† travers Swift, pour impl√©menter
des concepts tels que [des namespaces](https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918)
et
[des fonctionnalit√©s g√©n√©riques](https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43).

Mais `Never` ne fait pas parti de ceux-ci.
Il ne poss√®de pas de fonctionnalit√©s clinquantes.
C'est son contenu lui-m√™me (ou plut√¥t, son absence) qui le rend sp√©cial.

Consid√©rez une fonction d√©clarant retourner un type inhabit√© :
puisque les types inhabit√©s ne poss√®dent pas de valeurs,
il est impossible √† cette fonction de retourner normalement.
(Comment cela serait-il possible ?)
√Ä la place, cette fonction doit soit mettre fin √† l'ex√©cution,
soit s'ex√©cuter ind√©finiment.

## Supprimer des √©tats impossible dans les types g√©n√©riques

Bien s√ªr, cela est int√©ressant d'un point de vue th√©orique, mais quelle
utilisation pratique peut-on faire de `Never` ?

Pas grand chose ---
ou du moins avant l'acceptation de la proposition d'√©volution [SE-0215: Conform Never to Equatable and Hashable](https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable)

Dans cette proposition,
[Matt Diephouse](https://github.com/mdiep) explique que la motivation
derri√®re l'impl√©mentation d'`Equatable` et d'autres protocoles de cette fa√ßon :

> `Never` est tr√®s utile pour repr√©senter un chemin de code impossible.
> La plupart des gens se sont familiaris√©s avec lui via des fonctions comme
> `fatalError`, mais `Never` est √©galement tr√®s utile quand on manipule des
> classes g√©n√©riques.
> Par exemple, un type `Result` pourrait utiliser `Never` comme `Value`
> pour repr√©senter quelque chose qui produit syst√©matiquement une erreur
> ou utiliser `Never` comme `Error` pour repr√©senter quelque chose qui
> ne produit jamais d'erreur.

Swift ne poss√®de pas de type `Result` standard,
mais la plupart d'entre-eux ressemble √† ceci :

```swift
enum Result<Value, Error> {
    case success(Value)
    case failure(Error)
}
```

Les types `Result` sont utilis√©s pour encapsuler les valeurs et erreurs
produites par des fonctions qui s'ex√©cutent de fa√ßon asynchrone
(alors que des fonctions synchrones peuvent utiliser `throws` pour
transmettre des erreurs).

Par exemple,
une fonction qui r√©alise une requ√™te HTTP pourrait utiliser un `Result`
pour encapsuler, soit une r√©ponse et des donn√©es, soit une erreur :

```swift
func fetch(_ request: URLRequest,
          completion: (Result<(URLResponse, Data), Error>) -> Void) {
    // ...
}
```

√Ä l'appel de cette m√©thode,
il faudrait r√©aliser un switch sur son `result` pour g√©rer s√©par√©ment
les cas de `.success` et `.failure` :

```swift
fetch(request) { result in
    switch result {
    case let .success(response, _):
        print("Success: \(response)")
    case .failure(let error):
        print("Failure: \(error)")
    }
}
```

Consid√©rons maintenant une fonction qui garanti de toujours retourner un
succ√®s dans sa fonction de rappel :

```swift
func alwaysSucceeds(_ completion: (Result<String, Never>) -> Void) {
    completion(.success("yes!"))
}
```

En indiquant `Never` comme type d'`Error`,
nous utilisons le syst√®me de types pour indiquer qu'il n'est pas possible
au traitement d'√©chouer.
Ce qui est vraiment sympathique, c'est que Swift est suffisamment malin pour
r√©aliser qu'il n'y a pas besoin de g√©rer le cas `.failure` pour que l'instruction
`switch` soit exhaustive :

```swift
alwaysSucceeds { (result) in
    switch result {
    case .success(let string):
        print(string)
    }
}
```

Vous pouvez observer ce m√©canisme pouss√© √† son extr√™me
dans l'impl√©mentation permettant √† `Never` de se conformer
√† `Comparable` :

```swift
extension Never: Comparable {
  public static func < (lhs: Never, rhs: Never) -> Bool {
    switch (lhs, rhs) {}
  }
}
```

Puisque `Never` est un type inhabit√©,
il ne poss√®de aucune valeur.
Donc lorsque l'on r√©alise un switch sur
`lhs` et `rhs`, Swift comprend qu'aucun cas possible
n'est manquant.
Et puisque tous les cas --- qui sont simplement
au nombre de z√©ro --- retournent un bool√©en,
la m√©thode compile sans aucun probl√®me.

_Habile !_

---

## Never comme un Type Z√©ro

En corollaire,
la proposition d'√©volution originale pour `Never`,
fait allusion aux int√©r√™ts th√©oriques de ce type avec
quelque am√©liorations suppl√©mentaires :

> Un type inhabit√© peut √™tre vu comme un sous-type de n'importe
> quel autre type --- si l'√©valuation d'une expression ne produit
> jamais de valeur, peut importe le type de cette expression.
> Si cela √©tait pris en charge pas le compilateur, cela permettrait
> des choses potentiellement utiles...

### Unwrap ou meurt

L'op√©rateur force unwrap (`!`)
est une des parties les plus controvers√©es de Swift.
Au mieux, il s'agit d'un mal n√©cessaire.
Au pire, il est le signe d'un manque de rigueur.
Et sans information suppl√©mentaire,
il peut √™tre difficile de faire la diff√©rence entre les deux.

Par exemple,
consid√©rez le code suivant, qui suppose qu'un `array` n'est pas vide :

```swift
let array: [Int]
let firstIem = array.first!
```

Pour √©viter un force unwrap,
vous pourriez utiliser √† la place une instruction `guard` avec
une affectation conditionnelle :

```swift
let array: [Int]
guard let firstItem = array.first else {
    fatalError("array cannot be empty")
}
```

Dans le futur,
si `Never` est impl√©ment√© comme un type z√©ro,
il pourrait √™tre utilis√© dans le membre droit d'un op√©rateur `??`.

```swift
// Future Swift? üîÆ
let firstItem = array.first ?? fatalError("array cannot be empty")
```

Si vous √™tes vraiment motiv√©s pour adopter ce fonctionnement aujourd'hui,
vous pouvez manuellement surcharger l'op√©rateur `??` de cette fa√ßon (toutefois...) :

```swift
func ?? <T>(lhs: T?, rhs: @autoclosure () -> Never) -> T {
    switch lhs {
    case let value?:
        return value
    case nil:
        rhs()
    }
}
```

{% info do %}

Dans les [motivations](https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222)
derri√®re [SE-0217: Introducing the !! "Unwrap or Die" operator to the Swift Standard Library](https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps),
[Joe Groff](https://github.com/jckarter) indique que
"[...] Nous avons remarqu√© que surcharger [?? pour Never]
avait un impact inacceptable sur les performances du v√©rificateur de types...".
Ainsi, il est recommand√© de ne pas introduire cet ajout dans votre code.

{% endinfo %}

### Throw comme expression

Similairement,
si `throw` est modifi√© pour ne plus √™tre une instruction
mais une expression qui retourne `Never`,
vous pourriez utiliser `throw` dans le membre droit de `??` :

```swift
// Future Swift? üîÆ
let firstItem = array.first ?? throw Error.empty
```

### Throws typ√©

En nous aventurant encore plus loin :
si le mot-cl√© `throws` dans une d√©claration de fonction
supportait l'ajout de contraintes g√©n√©riques,
alors le type `Never` pourrait indiquer le fait q'une
fonction ne g√©n√®re pas d'erreur (d'une mani√®re similaire √†
celle de `Result`) :

```swift
// Future Swift? üîÆ
func neverThrows() throws<Never> {
    // ...
}

neverThrows() // pas besoin d'un `try` car la r√©ussite est garantie
```

---

Affirmer que quelque chose n'aura jamais lieu peut ressembler
√† inviter l'univers √† prouver le contraire.
Alors que les logiques modales ou doxastiques sauvent la face
en adoptant un compromis (_"cela √©tait vrai √† un moment, ou d√ª
moins je l'ai cru !"_), la logique temporelle impose un plus haut
niveau d'exigence √† ses propositions.

Heureusement pour nous, 
Swift s'impose √©galement les m√™mes garanties gr√¢ce √† un type des
plus improbables : `Never`.
